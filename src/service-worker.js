/* eslint-disable no-restricted-globals */
import { clientsClaim, } from 'workbox-core'
import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies'
import { CacheableResponsePlugin } from 'workbox-cacheable-response'


if ('storage' in navigator && 'estimate' in navigator.storage) {
  navigator.storage.estimate()
    .then(function (estimate) {
      console.log('estimate', estimate)
      console.log(`Using ${estimate.usage / 1_000_000_000}GB out of ${estimate.quota / 1_000_000_000} GBs.`)
    })
} else {
  console.warn('no storage or estimate')
}

if ('BackgroundFetchManager' in self) {
  console.log('browser supports background fetch')
} else {
  console.warn('no background fetch')
}


self.__WB_DISABLE_DEV_LOGS = false
// add an activate event listener to sw and inside it, calls `self.clients.claim()`
clientsClaim()


// One feature of service workers is the ability to save a set of files to the cache when the service worker is installing.
// Precache all the assets generated by your build process.
// Their URLs are injected into the manifest variable below. This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)


// workbox-core's skipWaiting() is deprecated, and developers should switch to calling self.skipWaiting() directly.
// see https://developer.chrome.com/docs/workbox/modules/workbox-core/#the-skipwaiting-wrapper-is-deprecated
// This allows the web app to trigger skipWaiting via registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  console.log('msg e:', event)
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})


// workbox-routing is a module which makes it easy to "route" these requests to different functions that provide responses
// Set up App Shell-style routing, so that all navigation requests are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
registerRoute(({ request, url }) => {
  // If this isn't a navigation, skip.
  if (request.mode !== 'navigate') {
    return false
  }

  // If this is a URL that starts with /_, skip.
  if (url.pathname.startsWith('/_')) {
    return false
  }

  // If this looks like a URL for a resource, because it contains // a file extension, skip.
  const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')
  if (url.pathname.match(fileExtensionRegexp)) {
    return false
  }

  // Return true to signal that we want to use the handler.
  return true
}, createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'))


// A runtime caching route for requests that aren't handled by the
// precache, in this case same-origin image requests like those from in public/
registerRoute(
  ({ request }) => {
    return request.destination === 'image'
  },
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200]
      })
    ]
  })
)


// A runtime caching route for requests the metadata of all courses
registerRoute(
  ({ url, request }) => {
    if (url.pathname.endsWith('/api/courses') || url.pathname.includes('/api/user-course-progresses/'))
      console.log('courses', url, request)
    return url.pathname.endsWith('/api/courses') || url.pathname.includes('/api/user-course-progresses/')
  },
  new StaleWhileRevalidate({
    cacheName: 'courses-meta'
  })
)
